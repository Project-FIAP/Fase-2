# -*- coding: utf-8 -*-
"""ViniciusLisboaPorto_RM561406_Fase3_cap10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DbPrGJGpWvm7ErSf4sjFmATBGYex57u8

# An√°lise Preditiva de Culturas Agr√≠colas

**Integrantes do Grupo:**
- Vinicius de Santana Gama - RM566672
- Pedro Carvalho Rocha Lima - RM567330
- Vinicius Lisboa Porto - RM561406
- Marlon Paulino Marinho - RM566793
- Danilo Marques Dantas - RM567583

**Objetivo:** Analisar condi√ß√µes de solo e clima para prever qual cultura agr√≠cola √© mais adequada para plantio, desenvolvendo modelos preditivos e identificando perfis ideais de cultivo.

---

## 1. Importa√ß√£o de Bibliotecas e Carregamento dos Dados
"""

# Bibliotecas fundamentais
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

# Bibliotecas para Machine Learning
from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.metrics import precision_score, recall_score, f1_score

# Algoritmos de classifica√ß√£o
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC

# Configura√ß√µes de visualiza√ß√£o
plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette("husl")
plt.rcParams['figure.figsize'] = (12, 6)
plt.rcParams['font.size'] = 10

print("‚úì Bibliotecas importadas com sucesso")

# Carregamento da base de dados
df = pd.read_csv('produtos_agricolas.csv')

print("Base de dados carregada com sucesso!")
print(f"Dimens√µes: {df.shape[0]} registros √ó {df.shape[1]} vari√°veis")

"""---
## 2. An√°lise Explorat√≥ria dos Dados

Nesta etapa inicial, vamos conhecer a estrutura da base, identificar padr√µes b√°sicos e verificar a qualidade dos dados.
"""

# Visualiza√ß√£o das primeiras linhas
print("=" * 80)
print("PRIMEIRAS LINHAS DA BASE")
print("=" * 80)
display(df.head(10))

# Informa√ß√µes gerais sobre a base
print("=" * 80)
print("INFORMA√á√ïES GERAIS")
print("=" * 80)
print(f"\nDimens√µes: {df.shape[0]} linhas √ó {df.shape[1]} colunas")
print(f"\nVari√°veis num√©ricas: N, P, K, temperature, humidity, ph, rainfall")
print(f"Vari√°vel categ√≥rica (target): label (tipo de cultura)")
print(f"\nMem√≥ria utilizada: {df.memory_usage(deep=True).sum() / 1024:.2f} KB")

# Tipos de dados e valores ausentes
print("\n" + "=" * 80)
print("QUALIDADE DOS DADOS")
print("=" * 80)

info_df = pd.DataFrame({
    'Tipo': df.dtypes,
    'Valores Ausentes': df.isnull().sum(),
    '% Ausentes': (df.isnull().sum() / len(df) * 100).round(2)
})
display(info_df)

print("\n‚úì Base de dados completa: nenhum valor ausente encontrado")

# Distribui√ß√£o das culturas
print("\n" + "=" * 80)
print("DISTRIBUI√á√ÉO DAS CULTURAS")
print("=" * 80)

culturas_count = df['label'].value_counts().sort_index()
print(f"\nTotal de culturas diferentes: {df['label'].nunique()}")
print(f"\nDistribui√ß√£o dos registros:")
for cultura, count in culturas_count.items():
    print(f"  ‚Ä¢ {cultura.capitalize()}: {count} registros ({count/len(df)*100:.1f}%)")

print("\n‚úì Base balanceada: cada cultura possui exatamente 100 registros")

# Estat√≠sticas descritivas das vari√°veis num√©ricas
print("\n" + "=" * 80)
print("ESTAT√çSTICAS DESCRITIVAS DAS VARI√ÅVEIS AMBIENTAIS E DE SOLO")
print("=" * 80)

stats_desc = df.describe().round(2)
display(stats_desc)

print("\nInterpreta√ß√£o:")
print("  ‚Ä¢ N (Nitrog√™nio): varia de 0 a 140 kg/ha, m√©dia de 50.55 kg/ha")
print("  ‚Ä¢ P (F√≥sforo): varia de 5 a 145 kg/ha, m√©dia de 53.36 kg/ha")
print("  ‚Ä¢ K (Pot√°ssio): varia de 5 a 205 kg/ha, m√©dia de 48.15 kg/ha")
print("  ‚Ä¢ Temperature: varia de 8.83¬∞C a 43.68¬∞C, m√©dia de 25.62¬∞C")
print("  ‚Ä¢ Humidity: varia de 14.26% a 99.98%, m√©dia de 71.48%")
print("  ‚Ä¢ pH: varia de 3.50 a 9.94, m√©dia de 6.47 (levemente √°cido)")
print("  ‚Ä¢ Rainfall: varia de 20.21mm a 298.56mm, m√©dia de 103.46mm")

"""---
## 3. An√°lise Descritiva com Visualiza√ß√µes

Aqui vamos explorar visualmente os padr√µes nos dados atrav√©s de gr√°ficos que revelam rela√ß√µes importantes entre as vari√°veis.

### 3.1. Gr√°fico 1: Distribui√ß√£o das Vari√°veis Ambientais
"""

# Gr√°fico 1: Histogramas das vari√°veis num√©ricas
fig, axes = plt.subplots(2, 4, figsize=(16, 8))
fig.suptitle('Distribui√ß√£o das Vari√°veis Ambientais e de Solo', fontsize=16, fontweight='bold')

variaveis = ['N', 'P', 'K', 'temperature', 'humidity', 'ph', 'rainfall']
titulos = ['Nitrog√™nio (N)', 'F√≥sforo (P)', 'Pot√°ssio (K)', 'Temperatura (¬∞C)',
           'Umidade (%)', 'pH do Solo', 'Precipita√ß√£o (mm)']

for idx, (var, titulo) in enumerate(zip(variaveis, titulos)):
    row = idx // 4
    col = idx % 4
    axes[row, col].hist(df[var], bins=30, color='steelblue', edgecolor='black', alpha=0.7)
    axes[row, col].set_title(titulo, fontweight='bold')
    axes[row, col].set_xlabel('Valor')
    axes[row, col].set_ylabel('Frequ√™ncia')
    axes[row, col].axvline(df[var].mean(), color='red', linestyle='--', linewidth=2, label=f'M√©dia: {df[var].mean():.1f}')
    axes[row, col].legend()

# Remover subplot extra
fig.delaxes(axes[1, 3])

plt.tight_layout()
plt.show()

print("\nInsights do Gr√°fico 1:")
print("  ‚Ä¢ Nitrog√™nio: distribui√ß√£o bimodal, indicando grupos de culturas com baixa e alta demanda")
print("  ‚Ä¢ Temperatura: distribui√ß√£o pr√≥xima √† normal, concentrada entre 20-30¬∞C")
print("  ‚Ä¢ pH: distribui√ß√£o levemente assim√©trica, maioria dos solos s√£o neutros a levemente √°cidos")
print("  ‚Ä¢ Precipita√ß√£o: grande variabilidade, refletindo diferentes necessidades h√≠dricas")

"""### 3.2. Gr√°fico 2: Matriz de Correla√ß√£o"""

# Gr√°fico 2: Matriz de correla√ß√£o
plt.figure(figsize=(10, 8))
correlation_matrix = df[variaveis].corr()

sns.heatmap(correlation_matrix, annot=True, fmt='.2f', cmap='coolwarm',
            center=0, square=True, linewidths=1, cbar_kws={"shrink": 0.8})
plt.title('Matriz de Correla√ß√£o entre Vari√°veis Ambientais e de Solo',
          fontsize=14, fontweight='bold', pad=20)
plt.tight_layout()
plt.show()

print("\nInsights do Gr√°fico 2:")
print("  ‚Ä¢ Baixa correla√ß√£o entre as vari√°veis (m√°ximo ~0.3), indicando independ√™ncia")
print("  ‚Ä¢ N√£o h√° multicolinearidade significativa, bom para modelos preditivos")
print("  ‚Ä¢ Cada vari√°vel contribui com informa√ß√£o √∫nica sobre as condi√ß√µes de cultivo")
print("  ‚Ä¢ Isso sugere que todas as 7 vari√°veis s√£o relevantes para a previs√£o")

"""### 3.3. Gr√°fico 3: Boxplot - Nutrientes por Cultura"""

# Gr√°fico 3: Boxplot dos nutrientes NPK
fig, axes = plt.subplots(1, 3, figsize=(16, 5))
fig.suptitle('Distribui√ß√£o de Nutrientes (N-P-K) por Cultura', fontsize=16, fontweight='bold')

nutrientes = ['N', 'P', 'K']
nomes_nutrientes = ['Nitrog√™nio (N)', 'F√≥sforo (P)', 'Pot√°ssio (K)']

for idx, (nutriente, nome) in enumerate(zip(nutrientes, nomes_nutrientes)):
    sns.boxplot(data=df, y='label', x=nutriente, ax=axes[idx], palette='Set2')
    axes[idx].set_title(nome, fontweight='bold')
    axes[idx].set_xlabel(f'{nutriente} (kg/ha)')
    axes[idx].set_ylabel('')

plt.tight_layout()
plt.show()

print("\nInsights do Gr√°fico 3:")
print("  ‚Ä¢ Culturas apresentam demandas nutricionais muito distintas")
print("  ‚Ä¢ Algod√£o (cotton) e caf√© (coffee) requerem alto N, P e K")
print("  ‚Ä¢ Arroz (rice) e leguminosas precisam de alto N")
print("  ‚Ä¢ Frutas geralmente demandam n√≠veis moderados de nutrientes")
print("  ‚Ä¢ A varia√ß√£o nutricional √© um forte preditor do tipo de cultura")

"""### 3.4. Gr√°fico 4: Condi√ß√µes Clim√°ticas por Cultura"""

# Gr√°fico 4: Scatter plot - Temperatura vs Umidade por Cultura
plt.figure(figsize=(14, 8))
culturas_unicas = df['label'].unique()
cores = sns.color_palette('tab20', n_colors=len(culturas_unicas))

for idx, cultura in enumerate(sorted(culturas_unicas)):
    dados_cultura = df[df['label'] == cultura]
    plt.scatter(dados_cultura['temperature'], dados_cultura['humidity'],
                label=cultura.capitalize(), alpha=0.6, s=50, color=cores[idx])

plt.xlabel('Temperatura (¬∞C)', fontsize=12, fontweight='bold')
plt.ylabel('Umidade (%)', fontsize=12, fontweight='bold')
plt.title('Rela√ß√£o entre Temperatura e Umidade por Cultura', fontsize=14, fontweight='bold')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', ncol=2)
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print("\nInsights do Gr√°fico 4:")
print("  ‚Ä¢ Culturas formam clusters distintos no espa√ßo temperatura-umidade")
print("  ‚Ä¢ Arroz: alta umidade (>80%) e temperatura moderada")
print("  ‚Ä¢ Caf√© e algod√£o: temperatura elevada (>22¬∞C) e umidade vari√°vel")
print("  ‚Ä¢ Leguminosas: preferem baixa umidade (<60%)")
print("  ‚Ä¢ A separa√ß√£o visual indica alta previsibilidade baseada nessas vari√°veis")

"""### 3.5. Gr√°fico 5: Precipita√ß√£o e pH - An√°lise Comparativa"""

# Gr√°fico 5: Violin plot - pH e Precipita√ß√£o
fig, axes = plt.subplots(1, 2, figsize=(16, 6))
fig.suptitle('Distribui√ß√£o de pH e Precipita√ß√£o por Cultura', fontsize=16, fontweight='bold')

# Selecionar culturas com maior varia√ß√£o para melhor visualiza√ß√£o
culturas_selecionadas = ['rice', 'maize', 'cotton', 'coffee', 'chickpea',
                          'kidneybeans', 'banana', 'mango', 'coconut', 'grapes']
df_filtrado = df[df['label'].isin(culturas_selecionadas)]

# pH
sns.violinplot(data=df_filtrado, y='label', x='ph', ax=axes[0], palette='muted')
axes[0].set_title('pH do Solo', fontweight='bold')
axes[0].set_xlabel('pH')
axes[0].set_ylabel('')
axes[0].axvline(7, color='red', linestyle='--', linewidth=1.5, alpha=0.5, label='pH Neutro')
axes[0].legend()

# Precipita√ß√£o
sns.violinplot(data=df_filtrado, y='label', x='rainfall', ax=axes[1], palette='muted')
axes[1].set_title('Precipita√ß√£o', fontweight='bold')
axes[1].set_xlabel('Precipita√ß√£o (mm)')
axes[1].set_ylabel('')

plt.tight_layout()
plt.show()

print("\nInsights do Gr√°fico 5:")
print("  ‚Ä¢ Arroz: requer alta precipita√ß√£o (>200mm) e pH neutro a levemente √°cido")
print("  ‚Ä¢ Caf√©: tolera ampla faixa de pH (5-7) e precipita√ß√£o moderada")
print("  ‚Ä¢ Algod√£o: prefere pH pr√≥ximo ao neutro e precipita√ß√£o moderada a baixa")
print("  ‚Ä¢ Leguminosas: adaptadas a baixa precipita√ß√£o (<70mm) e solos alcalinos")
print("  ‚Ä¢ Frutas tropicais: demandam pH √°cido e alta precipita√ß√£o")

"""---
## 4. Perfil Ideal de Solo e Clima

Nesta se√ß√£o, vamos calcular o perfil m√©dio ideal para cada vari√°vel e comparar como as tr√™s culturas escolhidas pelo grupo (Milho, Caf√© e Algod√£o) se posicionam em rela√ß√£o a esse perfil.
"""

# C√°lculo do perfil ideal (valores m√©dios globais)
perfil_ideal = df[variaveis].mean()

print("=" * 80)
print("PERFIL IDEAL DE SOLO E CLIMA (M√âDIAS GLOBAIS)")
print("=" * 80)
print(f"\nNitrog√™nio (N): {perfil_ideal['N']:.2f} kg/ha")
print(f"F√≥sforo (P): {perfil_ideal['P']:.2f} kg/ha")
print(f"Pot√°ssio (K): {perfil_ideal['K']:.2f} kg/ha")
print(f"Temperatura: {perfil_ideal['temperature']:.2f}¬∞C")
print(f"Umidade: {perfil_ideal['humidity']:.2f}%")
print(f"pH: {perfil_ideal['ph']:.2f}")
print(f"Precipita√ß√£o: {perfil_ideal['rainfall']:.2f} mm")

print("\n" + "=" * 80)
print("Interpreta√ß√£o do Perfil Ideal:")
print("=" * 80)
print("Este perfil representa as condi√ß√µes m√©dias encontradas na base de dados.")
print("Culturas que se aproximam desses valores possuem maior flexibilidade de cultivo,")
print("enquanto culturas com valores extremos possuem necessidades mais espec√≠ficas.")

"""### 4.1. An√°lise Comparativa: Milho, Caf√© e Algod√£o"""

# Perfis espec√≠ficos das culturas selecionadas
culturas_grupo = ['maize', 'coffee', 'cotton']
nomes_portugues = ['Milho', 'Caf√©', 'Algod√£o']

print("\n" + "=" * 80)
print("PERFIS DAS CULTURAS SELECIONADAS")
print("=" * 80)

perfis_culturas = {}
for cultura, nome_pt in zip(culturas_grupo, nomes_portugues):
    perfil = df[df['label'] == cultura][variaveis].mean()
    perfis_culturas[nome_pt] = perfil

    print(f"\n{nome_pt.upper()} ({cultura})")
    print("-" * 80)
    for var in variaveis:
        print(f"  {var:12s}: {perfil[var]:7.2f}")

# Criar DataFrame comparativo
df_comparacao = pd.DataFrame(perfis_culturas)
df_comparacao['Perfil Ideal'] = perfil_ideal

print("\n" + "=" * 80)
print("TABELA COMPARATIVA")
print("=" * 80)
display(df_comparacao.round(2))

# Visualiza√ß√£o comparativa
fig, axes = plt.subplots(2, 4, figsize=(18, 10))
fig.suptitle('Compara√ß√£o entre Milho, Caf√©, Algod√£o e Perfil Ideal',
             fontsize=16, fontweight='bold')

for idx, var in enumerate(variaveis):
    row = idx // 4
    col = idx % 4
    ax = axes[row, col]

    # Dados para o gr√°fico
    valores = [df_comparacao.loc[var, 'Milho'],
               df_comparacao.loc[var, 'Caf√©'],
               df_comparacao.loc[var, 'Algod√£o'],
               df_comparacao.loc[var, 'Perfil Ideal']]

    categorias = ['Milho', 'Caf√©', 'Algod√£o', 'Ideal']
    cores = ['#2E86AB', '#A23B72', '#F18F01', '#C73E1D']

    bars = ax.bar(categorias, valores, color=cores, alpha=0.7, edgecolor='black')
    ax.set_title(var.upper(), fontweight='bold')
    ax.set_ylabel('Valor')

    # Adicionar valores nas barras
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width()/2., height,
                f'{height:.1f}', ha='center', va='bottom', fontsize=9)

    ax.tick_params(axis='x', rotation=45)

# Remover subplot extra
fig.delaxes(axes[1, 3])

plt.tight_layout()
plt.show()

"""### 4.2. An√°lise Detalhada por Cultura"""

# An√°lise estat√≠stica comparativa
print("=" * 80)
print("AN√ÅLISE COMPARATIVA DETALHADA")
print("=" * 80)

print("\n1. MILHO (Maize)")
print("-" * 80)
print("Caracter√≠sticas em rela√ß√£o ao perfil ideal:")
milho_data = df[df['label'] == 'maize'][variaveis]
print(f"  ‚Ä¢ Nitrog√™nio: {milho_data['N'].mean():.1f} kg/ha (similar ao ideal: {perfil_ideal['N']:.1f})")
print(f"  ‚Ä¢ F√≥sforo: {milho_data['P'].mean():.1f} kg/ha (levemente abaixo do ideal: {perfil_ideal['P']:.1f})")
print(f"  ‚Ä¢ Pot√°ssio: {milho_data['K'].mean():.1f} kg/ha (abaixo do ideal: {perfil_ideal['K']:.1f})")
print(f"  ‚Ä¢ Temperatura: {milho_data['temperature'].mean():.1f}¬∞C (levemente abaixo do ideal: {perfil_ideal['temperature']:.1f})")
print(f"  ‚Ä¢ Umidade: {milho_data['humidity'].mean():.1f}% (significativamente abaixo do ideal: {perfil_ideal['humidity']:.1f})")
print(f"  ‚Ä¢ pH: {milho_data['ph'].mean():.2f} (pr√≥ximo ao ideal: {perfil_ideal['ph']:.2f})")
print(f"  ‚Ä¢ Precipita√ß√£o: {milho_data['rainfall'].mean():.1f} mm (abaixo do ideal: {perfil_ideal['rainfall']:.1f})")
print("\nInterpreta√ß√£o:")
print("  O milho adapta-se bem a condi√ß√µes de umidade moderada a baixa (55-60%),")
print("  preferindo climas mais secos que a m√©dia. Demanda nutricional equilibrada,")
print("  especialmente em NPK, e tolera ampla faixa de temperatura.")

print("\n2. CAF√â (Coffee)")
print("-" * 80)
print("Caracter√≠sticas em rela√ß√£o ao perfil ideal:")
cafe_data = df[df['label'] == 'coffee'][variaveis]
print(f"  ‚Ä¢ Nitrog√™nio: {cafe_data['N'].mean():.1f} kg/ha (MUITO ACIMA do ideal: {perfil_ideal['N']:.1f})")
print(f"  ‚Ä¢ F√≥sforo: {cafe_data['P'].mean():.1f} kg/ha (abaixo do ideal: {perfil_ideal['P']:.1f})")
print(f"  ‚Ä¢ Pot√°ssio: {cafe_data['K'].mean():.1f} kg/ha (abaixo do ideal: {perfil_ideal['K']:.1f})")
print(f"  ‚Ä¢ Temperatura: {cafe_data['temperature'].mean():.1f}¬∞C (similar ao ideal: {perfil_ideal['temperature']:.1f})")
print(f"  ‚Ä¢ Umidade: {cafe_data['humidity'].mean():.1f}% (abaixo do ideal: {perfil_ideal['humidity']:.1f})")
print(f"  ‚Ä¢ pH: {cafe_data['ph'].mean():.2f} (similar ao ideal: {perfil_ideal['ph']:.2f})")
print(f"  ‚Ä¢ Precipita√ß√£o: {cafe_data['rainfall'].mean():.1f} mm (MUITO ACIMA do ideal: {perfil_ideal['rainfall']:.1f})")
print("\nInterpreta√ß√£o:")
print("  O caf√© √© uma cultura exigente em nitrog√™nio (100+ kg/ha), necessitando de")
print("  fertiliza√ß√£o intensiva. Prefere alta precipita√ß√£o (>150mm) e temperatura")
print("  moderada constante. A umidade intermedi√°ria (50-65%) √© ideal para sua produ√ß√£o.")

print("\n3. ALGOD√ÉO (Cotton)")
print("-" * 80)
print("Caracter√≠sticas em rela√ß√£o ao perfil ideal:")
algodao_data = df[df['label'] == 'cotton'][variaveis]
print(f"  ‚Ä¢ Nitrog√™nio: {algodao_data['N'].mean():.1f} kg/ha (MUITO ACIMA do ideal: {perfil_ideal['N']:.1f})")
print(f"  ‚Ä¢ F√≥sforo: {algodao_data['P'].mean():.1f} kg/ha (acima do ideal: {perfil_ideal['P']:.1f})")
print(f"  ‚Ä¢ Pot√°ssio: {algodao_data['K'].mean():.1f} kg/ha (abaixo do ideal: {perfil_ideal['K']:.1f})")
print(f"  ‚Ä¢ Temperatura: {algodao_data['temperature'].mean():.1f}¬∞C (acima do ideal: {perfil_ideal['temperature']:.1f})")
print(f"  ‚Ä¢ Umidade: {algodao_data['humidity'].mean():.1f}% (MUITO ACIMA do ideal: {perfil_ideal['humidity']:.1f})")
print(f"  ‚Ä¢ pH: {algodao_data['ph'].mean():.2f} (levemente acima do ideal: {perfil_ideal['ph']:.2f})")
print(f"  ‚Ä¢ Precipita√ß√£o: {algodao_data['rainfall'].mean():.1f} mm (levemente acima do ideal: {perfil_ideal['rainfall']:.1f})")
print("\nInterpreta√ß√£o:")
print("  O algod√£o destaca-se por sua demanda extrema de nutrientes, especialmente N e P,")
print("  e por preferir temperaturas elevadas (>25¬∞C) e alta umidade (>80%). Requer")
print("  condi√ß√µes tropicais/subtropicais com precipita√ß√£o generosa e solo alcalino.")

# C√°lculo de dist√¢ncia do perfil ideal (m√©trica de similaridade)
from scipy.spatial.distance import euclidean

# Normalizar para compara√ß√£o justa
scaler = StandardScaler()
df_normalizado = pd.DataFrame(
    scaler.fit_transform(df[variaveis]),
    columns=variaveis
)
df_normalizado['label'] = df['label'].values

# Perfil ideal normalizado
perfil_ideal_norm = df_normalizado[variaveis].mean()

# Calcular dist√¢ncia euclidiana m√©dia por cultura
distancias = {}
for cultura in culturas_grupo:
    dados_cultura = df_normalizado[df_normalizado['label'] == cultura][variaveis]
    distancia_media = dados_cultura.apply(
        lambda row: euclidean(row, perfil_ideal_norm), axis=1
    ).mean()
    distancias[cultura] = distancia_media

print("\n" + "=" * 80)
print("DIST√ÇNCIA DO PERFIL IDEAL (quanto menor, mais pr√≥ximo do ideal)")
print("=" * 80)
for cultura, dist in sorted(distancias.items(), key=lambda x: x[1]):
    nome_pt = dict(zip(culturas_grupo, nomes_portugues))[cultura]
    print(f"  {nome_pt:10s} ({cultura:7s}): {dist:.4f}")

print("\nConclus√£o:")
cultura_mais_proxima = min(distancias, key=distancias.get)
nome_mais_proxima = dict(zip(culturas_grupo, nomes_portugues))[cultura_mais_proxima]
print(f"  O {nome_mais_proxima} √© a cultura mais pr√≥xima do perfil ideal,")
print(f"  indicando maior versatilidade de cultivo em diferentes condi√ß√µes.")

"""### 4.3. S√≠ntese Comparativa"""

print("=" * 80)
print("S√çNTESE: COMPARA√á√ÉO ENTRE MILHO, CAF√â E ALGOD√ÉO")
print("=" * 80)

print("\n1. DEMANDA NUTRICIONAL (N-P-K)")
print("-" * 80)
print("  Alta demanda: Caf√© e Algod√£o (especialmente Nitrog√™nio >100 kg/ha)")
print("  Demanda moderada: Milho (50-60 kg/ha de NPK)")
print("\n  ‚Üí Caf√© e Algod√£o requerem fertiliza√ß√£o intensiva")
print("  ‚Üí Milho √© mais econ√¥mico em termos de insumos")

print("\n2. CONDI√á√ïES CLIM√ÅTICAS")
print("-" * 80)
print("  Temperatura:")
print("    ‚Ä¢ Algod√£o prefere CALOR (>25¬∞C)")
print("    ‚Ä¢ Caf√© e Milho adaptam-se bem a temperaturas moderadas (23-25¬∞C)")
print("\n  Umidade:")
print("    ‚Ä¢ Algod√£o requer ALTA umidade (>80%)")
print("    ‚Ä¢ Caf√© tolera umidade moderada (50-65%)")
print("    ‚Ä¢ Milho prefere BAIXA umidade (<60%)")
print("\n  Precipita√ß√£o:")
print("    ‚Ä¢ Caf√© demanda ALTA precipita√ß√£o (>150mm)")
print("    ‚Ä¢ Algod√£o requer precipita√ß√£o moderada-alta (>100mm)")
print("    ‚Ä¢ Milho adapta-se a BAIXA precipita√ß√£o (<70mm)")

print("\n3. CARACTER√çSTICAS DE SOLO")
print("-" * 80)
print("  pH:")
print("    ‚Ä¢ Algod√£o prefere solos ALCALINOS (pH 6.8-7.5)")
print("    ‚Ä¢ Caf√© tolera solos NEUTROS a levemente √°cidos (pH 6.2-6.5)")
print("    ‚Ä¢ Milho adapta-se bem a solos NEUTROS (pH 6.2-6.5)")

print("\n4. PERFIL DE CULTIVO")
print("-" * 80)
print("  MILHO: Cultura vers√°til, baixa demanda h√≠drica e nutricional moderada")
print("         ‚Üí Ideal para regi√µes de clima seco e recursos limitados")
print("\n  CAF√â: Exigente em nitrog√™nio e √°gua, temperatura constante")
print("        ‚Üí Ideal para regi√µes tropicais de altitude com boa precipita√ß√£o")
print("\n  ALGOD√ÉO: Alta demanda de nutrientes, calor e umidade")
print("           ‚Üí Ideal para regi√µes tropicais √∫midas com fertiliza√ß√£o intensiva")

print("\n" + "=" * 80)

"""---
## 5. Desenvolvimento de Modelos Preditivos

Vamos desenvolver 5 modelos de Machine Learning diferentes para prever qual cultura √© mais adequada dadas as condi√ß√µes de solo e clima.

### 5.1. Prepara√ß√£o dos Dados
"""

# Separa√ß√£o de features e target
X = df[variaveis]
y = df['label']

print("=" * 80)
print("PREPARA√á√ÉO DOS DADOS PARA MODELAGEM")
print("=" * 80)
print(f"\nFeatures (X): {X.shape}")
print(f"Target (y): {y.shape}")
print(f"\nVari√°veis preditoras: {list(X.columns)}")
print(f"N√∫mero de classes: {y.nunique()}")

# Divis√£o treino-teste com estratifica√ß√£o
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

print(f"\nDivis√£o realizada:")
print(f"  ‚Ä¢ Conjunto de treino: {X_train.shape[0]} amostras ({X_train.shape[0]/len(X)*100:.1f}%)")
print(f"  ‚Ä¢ Conjunto de teste: {X_test.shape[0]} amostras ({X_test.shape[0]/len(X)*100:.1f}%)")
print(f"\n‚úì Estratifica√ß√£o aplicada para manter propor√ß√£o de classes")

# Normaliza√ß√£o dos dados
scaler_model = StandardScaler()
X_train_scaled = scaler_model.fit_transform(X_train)
X_test_scaled = scaler_model.transform(X_test)

print("\n‚úì Normaliza√ß√£o aplicada (StandardScaler)")
print("  Importante para algoritmos sens√≠veis √† escala (KNN, SVM)")

"""### 5.2. Modelo 1: Random Forest"""

print("\n" + "=" * 80)
print("MODELO 1: RANDOM FOREST")
print("=" * 80)
print("\nCaracter√≠sticas:")
print("  ‚Ä¢ Ensemble de m√∫ltiplas √°rvores de decis√£o")
print("  ‚Ä¢ Robusto a overfitting e outliers")
print("  ‚Ä¢ Fornece import√¢ncia das features")
print("  ‚Ä¢ N√£o requer normaliza√ß√£o dos dados")

# Treinamento
rf_model = RandomForestClassifier(
    n_estimators=150,
    max_depth=20,
    min_samples_split=5,
    min_samples_leaf=2,
    random_state=42,
    n_jobs=-1
)

rf_model.fit(X_train, y_train)
y_pred_rf = rf_model.predict(X_test)

# Avalia√ß√£o
acc_rf = accuracy_score(y_test, y_pred_rf)
print(f"\n‚úì Acur√°cia no conjunto de teste: {acc_rf*100:.2f}%")

# Cross-validation
cv_scores_rf = cross_val_score(rf_model, X_train, y_train, cv=5, scoring='accuracy')
print(f"‚úì Acur√°cia m√©dia (5-fold CV): {cv_scores_rf.mean()*100:.2f}% (¬±{cv_scores_rf.std()*100:.2f}%)")

# Import√¢ncia das features
importancias_rf = pd.DataFrame({
    'Feature': X.columns,
    'Import√¢ncia': rf_model.feature_importances_
}).sort_values('Import√¢ncia', ascending=False)

print("\nImport√¢ncia das Features:")
for idx, row in importancias_rf.iterrows():
    print(f"  {row['Feature']:12s}: {row['Import√¢ncia']:.4f}")

"""### 5.3. Modelo 2: Gradient Boosting"""

print("\n" + "=" * 80)
print("MODELO 2: GRADIENT BOOSTING")
print("=" * 80)
print("\nCaracter√≠sticas:")
print("  ‚Ä¢ Constru√ß√£o sequencial de √°rvores fracas")
print("  ‚Ä¢ Cada √°rvore corrige erros da anterior")
print("  ‚Ä¢ Alta performance, mas mais lento para treinar")
print("  ‚Ä¢ Sens√≠vel a hiperpar√¢metros")

# Treinamento
gb_model = GradientBoostingClassifier(
    n_estimators=120,
    learning_rate=0.1,
    max_depth=8,
    min_samples_split=5,
    min_samples_leaf=2,
    subsample=0.8,
    random_state=42
)

gb_model.fit(X_train, y_train)
y_pred_gb = gb_model.predict(X_test)

# Avalia√ß√£o
acc_gb = accuracy_score(y_test, y_pred_gb)
print(f"\n‚úì Acur√°cia no conjunto de teste: {acc_gb*100:.2f}%")

# Cross-validation
cv_scores_gb = cross_val_score(gb_model, X_train, y_train, cv=5, scoring='accuracy')
print(f"‚úì Acur√°cia m√©dia (5-fold CV): {cv_scores_gb.mean()*100:.2f}% (¬±{cv_scores_gb.std()*100:.2f}%)")

"""### 5.4. Modelo 3: Decision Tree"""

print("\n" + "=" * 80)
print("MODELO 3: DECISION TREE (√ÅRVORE DE DECIS√ÉO)")
print("=" * 80)
print("\nCaracter√≠sticas:")
print("  ‚Ä¢ Estrutura de √°rvore com regras if-then-else")
print("  ‚Ä¢ F√°cil interpreta√ß√£o e visualiza√ß√£o")
print("  ‚Ä¢ Tende a overfitting sem poda adequada")
print("  ‚Ä¢ R√°pido para treinar e prever")

# Treinamento
dt_model = DecisionTreeClassifier(
    max_depth=15,
    min_samples_split=8,
    min_samples_leaf=3,
    criterion='gini',
    random_state=42
)

dt_model.fit(X_train, y_train)
y_pred_dt = dt_model.predict(X_test)

# Avalia√ß√£o
acc_dt = accuracy_score(y_test, y_pred_dt)
print(f"\n‚úì Acur√°cia no conjunto de teste: {acc_dt*100:.2f}%")

# Cross-validation
cv_scores_dt = cross_val_score(dt_model, X_train, y_train, cv=5, scoring='accuracy')
print(f"‚úì Acur√°cia m√©dia (5-fold CV): {cv_scores_dt.mean()*100:.2f}% (¬±{cv_scores_dt.std()*100:.2f}%)")

"""### 5.5. Modelo 4: K-Nearest Neighbors (KNN)"""

print("\n" + "=" * 80)
print("MODELO 4: K-NEAREST NEIGHBORS (KNN)")
print("=" * 80)
print("\nCaracter√≠sticas:")
print("  ‚Ä¢ Classifica√ß√£o baseada em proximidade")
print("  ‚Ä¢ N√£o param√©trico (n√£o faz suposi√ß√µes sobre distribui√ß√£o)")
print("  ‚Ä¢ Sens√≠vel √† escala (requer normaliza√ß√£o)")
print("  ‚Ä¢ Lento para grandes datasets")

# Treinamento (usando dados normalizados)
knn_model = KNeighborsClassifier(
    n_neighbors=7,
    weights='distance',
    metric='minkowski',
    p=2,
    n_jobs=-1
)

knn_model.fit(X_train_scaled, y_train)
y_pred_knn = knn_model.predict(X_test_scaled)

# Avalia√ß√£o
acc_knn = accuracy_score(y_test, y_pred_knn)
print(f"\n‚úì Acur√°cia no conjunto de teste: {acc_knn*100:.2f}%")

# Cross-validation
cv_scores_knn = cross_val_score(knn_model, X_train_scaled, y_train, cv=5, scoring='accuracy')
print(f"‚úì Acur√°cia m√©dia (5-fold CV): {cv_scores_knn.mean()*100:.2f}% (¬±{cv_scores_knn.std()*100:.2f}%)")

"""### 5.6. Modelo 5: Support Vector Machine (SVM)"""

print("\n" + "=" * 80)
print("MODELO 5: SUPPORT VECTOR MACHINE (SVM)")
print("=" * 80)
print("\nCaracter√≠sticas:")
print("  ‚Ä¢ Busca hiperplano √≥timo de separa√ß√£o")
print("  ‚Ä¢ Eficaz em espa√ßos de alta dimensionalidade")
print("  ‚Ä¢ Kernel RBF permite separa√ß√£o n√£o-linear")
print("  ‚Ä¢ Computacionalmente intensivo para grandes datasets")

# Treinamento (usando dados normalizados)
svm_model = SVC(
    C=10,
    kernel='rbf',
    gamma='scale',
    random_state=42,
    cache_size=1000
)

svm_model.fit(X_train_scaled, y_train)
y_pred_svm = svm_model.predict(X_test_scaled)

# Avalia√ß√£o
acc_svm = accuracy_score(y_test, y_pred_svm)
print(f"\n‚úì Acur√°cia no conjunto de teste: {acc_svm*100:.2f}%")

# Cross-validation
cv_scores_svm = cross_val_score(svm_model, X_train_scaled, y_train, cv=5, scoring='accuracy')
print(f"‚úì Acur√°cia m√©dia (5-fold CV): {cv_scores_svm.mean()*100:.2f}% (¬±{cv_scores_svm.std()*100:.2f}%)")

"""---
## 6. Compara√ß√£o de Performance dos Modelos
"""

# Compilar resultados
resultados = pd.DataFrame({
    'Modelo': ['Random Forest', 'Gradient Boosting', 'Decision Tree', 'KNN', 'SVM'],
    'Acur√°cia Teste': [acc_rf, acc_gb, acc_dt, acc_knn, acc_svm],
    'Acur√°cia CV (m√©dia)': [
        cv_scores_rf.mean(),
        cv_scores_gb.mean(),
        cv_scores_dt.mean(),
        cv_scores_knn.mean(),
        cv_scores_svm.mean()
    ],
    'Desvio Padr√£o CV': [
        cv_scores_rf.std(),
        cv_scores_gb.std(),
        cv_scores_dt.std(),
        cv_scores_knn.std(),
        cv_scores_svm.std()
    ]
})

resultados['Acur√°cia Teste'] = (resultados['Acur√°cia Teste'] * 100).round(2)
resultados['Acur√°cia CV (m√©dia)'] = (resultados['Acur√°cia CV (m√©dia)'] * 100).round(2)
resultados['Desvio Padr√£o CV'] = (resultados['Desvio Padr√£o CV'] * 100).round(2)

resultados = resultados.sort_values('Acur√°cia Teste', ascending=False).reset_index(drop=True)

print("=" * 80)
print("COMPARA√á√ÉO DE PERFORMANCE DOS MODELOS")
print("=" * 80)
display(resultados)

melhor_modelo = resultados.iloc[0]['Modelo']
melhor_acc = resultados.iloc[0]['Acur√°cia Teste']
print(f"\nüèÜ Melhor modelo: {melhor_modelo} com {melhor_acc:.2f}% de acur√°cia")

# Visualiza√ß√£o comparativa
fig, axes = plt.subplots(1, 2, figsize=(16, 6))

# Gr√°fico 1: Acur√°cia no teste
cores_barras = ['#2E86AB' if modelo == melhor_modelo else '#A9A9A9'
                for modelo in resultados['Modelo']]
axes[0].barh(resultados['Modelo'], resultados['Acur√°cia Teste'], color=cores_barras, edgecolor='black')
axes[0].set_xlabel('Acur√°cia (%)', fontweight='bold')
axes[0].set_title('Acur√°cia no Conjunto de Teste', fontweight='bold')
axes[0].set_xlim([90, 100])
for i, v in enumerate(resultados['Acur√°cia Teste']):
    axes[0].text(v + 0.2, i, f'{v:.2f}%', va='center')

# Gr√°fico 2: Acur√°cia CV com desvio padr√£o
x_pos = np.arange(len(resultados))
axes[1].bar(x_pos, resultados['Acur√°cia CV (m√©dia)'],
            yerr=resultados['Desvio Padr√£o CV'],
            color=cores_barras, edgecolor='black',
            capsize=5, alpha=0.7)
axes[1].set_xticks(x_pos)
axes[1].set_xticklabels(resultados['Modelo'], rotation=45, ha='right')
axes[1].set_ylabel('Acur√°cia (%)', fontweight='bold')
axes[1].set_title('Acur√°cia com Cross-Validation (5-fold)', fontweight='bold')
axes[1].set_ylim([90, 100])

plt.tight_layout()
plt.show()

print("\nInsights:")
print(f"  ‚Ä¢ {melhor_modelo} demonstra a melhor performance geral")
print("  ‚Ä¢ Todos os modelos apresentam acur√°cia superior a 95%")
print("  ‚Ä¢ Baixo desvio padr√£o indica estabilidade dos modelos")
print("  ‚Ä¢ A separa√ß√£o das culturas √© bem definida nos dados")

"""### 6.1. M√©tricas Detalhadas do Melhor Modelo"""

# An√°lise detalhada do melhor modelo (Random Forest)
print("=" * 80)
print(f"AN√ÅLISE DETALHADA: {melhor_modelo.upper()}")
print("=" * 80)

# Classification Report
print("\nRelat√≥rio de Classifica√ß√£o:")
print(classification_report(y_test, y_pred_rf, zero_division=0))

# M√©tricas agregadas
precision_macro = precision_score(y_test, y_pred_rf, average='macro', zero_division=0)
recall_macro = recall_score(y_test, y_pred_rf, average='macro', zero_division=0)
f1_macro = f1_score(y_test, y_pred_rf, average='macro', zero_division=0)

print(f"\nM√©tricas Macro-Averaged:")
print(f"  ‚Ä¢ Precis√£o: {precision_macro*100:.2f}%")
print(f"  ‚Ä¢ Recall: {recall_macro*100:.2f}%")
print(f"  ‚Ä¢ F1-Score: {f1_macro*100:.2f}%")

# Matriz de Confus√£o
cm = confusion_matrix(y_test, y_pred_rf)
plt.figure(figsize=(14, 12))

sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=sorted(df['label'].unique()),
            yticklabels=sorted(df['label'].unique()),
            cbar_kws={'label': 'Quantidade de Predi√ß√µes'})

plt.title(f'Matriz de Confus√£o - {melhor_modelo}', fontsize=14, fontweight='bold', pad=20)
plt.ylabel('Classe Real', fontweight='bold')
plt.xlabel('Classe Prevista', fontweight='bold')
plt.xticks(rotation=45, ha='right')
plt.yticks(rotation=0)
plt.tight_layout()
plt.show()

print("\nInterpreta√ß√£o da Matriz de Confus√£o:")
print("  ‚Ä¢ Diagonal principal (azul escuro): predi√ß√µes corretas")
print("  ‚Ä¢ C√©lulas fora da diagonal: erros de classifica√ß√£o")
print("  ‚Ä¢ Modelo demonstra alta precis√£o em todas as classes")
print("  ‚Ä¢ Poucos casos de confus√£o entre culturas similares")

"""---
## 7. Conclus√µes e Limita√ß√µes

Nesta se√ß√£o final, consolidamos os principais achados do estudo e discutimos as limita√ß√µes encontradas.

### 7.1. Principais Achados
"""

print("=" * 80)
print("PRINCIPAIS ACHADOS DO ESTUDO")
print("=" * 80)

print("\n1. QUALIDADE E ESTRUTURA DOS DADOS")
print("-" * 80)
print(f"  ‚Ä¢ Base de dados completa e balanceada: {df.shape[0]} registros, 22 culturas")
print("  ‚Ä¢ Nenhum valor ausente ou inconsistente")
print("  ‚Ä¢ Cada cultura possui exatamente 100 registros (4,5% cada)")
print("  ‚Ä¢ 7 vari√°veis preditoras com baixa correla√ß√£o entre si (independ√™ncia)")
print("  ‚Ä¢ Distribui√ß√µes variadas refletem diversidade de condi√ß√µes agr√≠colas")

print("\n2. AN√ÅLISE DO PERFIL IDEAL E COMPARA√á√ÉO (MILHO, CAF√â, ALGOD√ÉO)")
print("-" * 80)
print("  ‚Ä¢ Perfil ideal representa condi√ß√µes m√©dias globais")
print("  ‚Ä¢ Milho: cultura vers√°til, pr√≥xima do ideal, baixa demanda h√≠drica")
print("  ‚Ä¢ Caf√©: alta demanda de nitrog√™nio (>100 kg/ha) e precipita√ß√£o (>150mm)")
print("  ‚Ä¢ Algod√£o: extrema demanda nutricional e prefer√™ncia por calor e umidade")
print("  ‚Ä¢ Cada cultura possui assinatura √∫nica de solo-clima")
print("  ‚Ä¢ Varia√ß√£o ambiental √© determinante para escolha da cultura")

print("\n3. PERFORMANCE DOS MODELOS PREDITIVOS")
print("-" * 80)
acc_list = [acc_rf, acc_gb, acc_dt, acc_knn, acc_svm]
print(f"  ‚Ä¢ Todos os modelos alcan√ßaram acur√°cia > 95% no teste")
print(f"  ‚Ä¢ Melhor modelo: {melhor_modelo} ({melhor_acc:.2f}%)")
print(f"  ‚Ä¢ Acur√°cia m√©dia dos 5 modelos: {np.mean(acc_list)*100:.2f}%")
print(f"  ‚Ä¢ Baixa vari√¢ncia entre modelos indica dados bem estruturados")
print(f"  ‚Ä¢ Cross-validation confirma robustez (baixo desvio padr√£o)")
print("  ‚Ä¢ Random Forest e Gradient Boosting foram os mais eficazes")

print("\n4. IMPORT√ÇNCIA DAS VARI√ÅVEIS (RANDOM FOREST)")
print("-" * 80)
print("  Top 3 vari√°veis mais importantes:")
for idx, row in importancias_rf.head(3).iterrows():
    print(f"    {idx+1}. {row['Feature']:12s}: {row['Import√¢ncia']:.4f}")
print("  ‚Ä¢ Todas as 7 vari√°veis contribuem significativamente")
print("  ‚Ä¢ Nutrientes (NPK) e fatores clim√°ticos s√£o igualmente relevantes")

print("\n5. APLICABILIDADE PR√ÅTICA")
print("-" * 80)
print("  ‚Ä¢ Modelos podem auxiliar agricultores na tomada de decis√£o")
print("  ‚Ä¢ Previs√£o r√°pida e precisa do tipo de cultura mais adequado")
print("  ‚Ä¢ Redu√ß√£o de custos com plantios inadequados")
print("  ‚Ä¢ Otimiza√ß√£o do uso de recursos naturais e insumos")
print("  ‚Ä¢ Potencial para integra√ß√£o em sistemas de agricultura de precis√£o")

"""### 7.2. Limita√ß√µes do Estudo"""

print("\n" + "=" * 80)
print("LIMITA√á√ïES E CONSIDERA√á√ïES CR√çTICAS")
print("=" * 80)

print("\n1. LIMITA√á√ïES DOS DADOS")
print("-" * 80)
print("  ‚Ä¢ Dataset relativamente pequeno (2.200 registros)")
print("  ‚Ä¢ Distribui√ß√£o uniforme pode n√£o refletir realidade de mercado")
print("  ‚Ä¢ Aus√™ncia de dados temporais (sazonalidade, ciclos de cultivo)")
print("  ‚Ä¢ Falta de informa√ß√µes sobre:")
print("    - Qualidade e textura do solo (arenoso, argiloso, etc.)")
print("    - Topografia e drenagem do terreno")
print("    - Hist√≥rico de pragas e doen√ßas")
print("    - Custos de produ√ß√£o e viabilidade econ√¥mica")
print("    - Disponibilidade de √°gua para irriga√ß√£o")
print("  ‚Ä¢ N√£o considera varia√ß√µes clim√°ticas extremas")

print("\n2. LIMITA√á√ïES DOS MODELOS")
print("-" * 80)
print("  ‚Ä¢ Modelos assumem condi√ß√µes est√°ticas (n√£o capturam mudan√ßas temporais)")
print("  ‚Ä¢ Alta acur√°cia pode indicar overfitting ao dataset espec√≠fico")
print("  ‚Ä¢ N√£o foram testados hiperpar√¢metros exaustivamente (devido ao escopo)")
print("  ‚Ä¢ Modelos s√£o 'caixas pretas' (exceto Decision Tree)")
print("  ‚Ä¢ N√£o consideram intera√ß√µes complexas entre vari√°veis")
print("  ‚Ä¢ Aus√™ncia de valida√ß√£o com dados externos (novos terrenos)")

print("\n3. LIMITA√á√ïES PR√ÅTICAS")
print("-" * 80)
print("  ‚Ä¢ Coleta de dados de solo/clima pode ser custosa para agricultores")
print("  ‚Ä¢ Modelos n√£o consideram aspectos log√≠sticos (transporte, armazenamento)")
print("  ‚Ä¢ Falta de integra√ß√£o com mercado (pre√ßos, demanda)")
print("  ‚Ä¢ N√£o considera prefer√™ncias e experi√™ncia do agricultor")
print("  ‚Ä¢ Aus√™ncia de an√°lise de risco e retorno financeiro")
print("  ‚Ä¢ Mudan√ßas clim√°ticas podem afetar previs√µes futuras")

print("\n4. VI√âS E GENERALIZA√á√ÉO")
print("-" * 80)
print("  ‚Ä¢ Dataset pode conter vi√©s geogr√°fico (regi√µes espec√≠ficas)")
print("  ‚Ä¢ Resultados podem n√£o generalizar para todas as regi√µes do mundo")
print("  ‚Ä¢ Diferentes cultivares de uma mesma cultura n√£o foram considerados")
print("  ‚Ä¢ Pr√°ticas agron√¥micas (aduba√ß√£o, irriga√ß√£o) afetam requisitos reais")

print("\n5. CONSIDERA√á√ïES √âTICAS E SOCIAIS")
print("-" * 80)
print("  ‚Ä¢ Modelos n√£o substituem conhecimento e experi√™ncia de agricultores")
print("  ‚Ä¢ Decis√µes devem considerar contexto social e cultural local")
print("  ‚Ä¢ Importante avaliar impacto ambiental de monoculturas")
print("  ‚Ä¢ Seguran√ßa alimentar e biodiversidade devem ser priorizadas")

"""### 7.3. Recomenda√ß√µes para Trabalhos Futuros"""

print("\n" + "=" * 80)
print("RECOMENDA√á√ïES PARA TRABALHOS FUTUROS")
print("=" * 80)

print("\n1. MELHORIA DOS DADOS")
print("-" * 80)
print("  ‚Ä¢ Coletar mais registros (>10.000) para maior robustez")
print("  ‚Ä¢ Incluir dados temporais (sazonalidade, anos consecutivos)")
print("  ‚Ä¢ Adicionar vari√°veis sobre textura e qualidade do solo")
print("  ‚Ä¢ Incorporar dados de produtividade real (t/ha)")
print("  ‚Ä¢ Considerar custos de produ√ß√£o e pre√ßos de mercado")

print("\n2. APRIMORAMENTO DOS MODELOS")
print("-" * 80)
print("  ‚Ä¢ Testar modelos de ensemble mais sofisticados (XGBoost, LightGBM)")
print("  ‚Ä¢ Implementar deep learning (redes neurais) para capturar padr√µes complexos")
print("  ‚Ä¢ Realizar busca em grid mais ampla de hiperpar√¢metros")
print("  ‚Ä¢ Desenvolver modelos multi-output (prever produtividade + cultura)")
print("  ‚Ä¢ Implementar an√°lise de incerteza nas previs√µes")

print("\n3. VALIDA√á√ÉO E DEPLOY")
print("-" * 80)
print("  ‚Ä¢ Validar modelos com dados de diferentes regi√µes geogr√°ficas")
print("  ‚Ä¢ Realizar estudos de caso com agricultores reais")
print("  ‚Ä¢ Desenvolver interface web/mobile para uso pr√°tico")
print("  ‚Ä¢ Integrar com APIs de dados clim√°ticos em tempo real")
print("  ‚Ä¢ Implementar sistema de feedback para melhoria cont√≠nua")

print("\n4. EXPANS√ÉO DO ESCOPO")
print("-" * 80)
print("  ‚Ä¢ Incluir an√°lise de viabilidade econ√¥mica e ROI")
print("  ‚Ä¢ Considerar rota√ß√£o de culturas e cons√≥rcio")
print("  ‚Ä¢ Avaliar impacto ambiental e sustentabilidade")
print("  ‚Ä¢ Desenvolver recomenda√ß√µes de manejo espec√≠ficas por cultura")
print("  ‚Ä¢ Integrar com sensoriamento remoto (imagens de sat√©lite)")

print("\n" + "=" * 80)

"""### 7.4. Conclus√£o Final"""

print("\n" + "=" * 80)
print("CONCLUS√ÉO FINAL")
print("=" * 80)

print("""
Este estudo demonstrou a viabilidade de usar Machine Learning para prever o tipo
de cultura agr√≠cola mais adequado com base em condi√ß√µes de solo e clima. Os cinco
modelos desenvolvidos alcan√ßaram performance excepcional (>95% de acur√°cia), com
destaque para Random Forest e Gradient Boosting.

A an√°lise explorat√≥ria revelou que cada cultura possui um "perfil" √∫nico de
necessidades ambientais e nutricionais. A compara√ß√£o entre Milho, Caf√© e Algod√£o
evidenciou diferen√ßas marcantes:
  ‚Ä¢ Milho: versatilidade e baixa demanda h√≠drica
  ‚Ä¢ Caf√©: alto requerimento de nitrog√™nio e precipita√ß√£o
  ‚Ä¢ Algod√£o: demanda extrema de nutrientes e prefer√™ncia por calor

Apesar das limita√ß√µes identificadas (tamanho do dataset, aus√™ncia de vari√°veis
econ√¥micas e temporais), os resultados s√£o promissores e abrem caminho para
aplica√ß√µes pr√°ticas em agricultura de precis√£o.

Os modelos desenvolvidos podem servir como ferramenta de apoio √† decis√£o para
agricultores, t√©cnicos e gestores, contribuindo para:
  ‚úì Otimiza√ß√£o do uso de recursos naturais
  ‚úì Redu√ß√£o de custos com plantios inadequados
  ‚úì Aumento da produtividade agr√≠cola
  ‚úì Promo√ß√£o de pr√°ticas agr√≠colas sustent√°veis

O trabalho evidencia o potencial da Intelig√™ncia Artificial no agroneg√≥cio,
refor√ßando a import√¢ncia de investimentos em pesquisa e desenvolvimento de
tecnologias que tornem a agricultura mais eficiente, sustent√°vel e rent√°vel.
""")

print("=" * 80)
print("FIM DO RELAT√ìRIO")
print("=" * 80)